<!DOCTYPE html>

<title>Competitive Programming - January 24, 2019</title>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="/notes/notes.css">

<header>
    <h1>Competitive Programming</h1>
    <time datetime="2019-01-24">January 24, 2019</time>
</header>

<article>
    <p>
    Reminder: when you google <strong>anything</strong> or refer to <strong>any</strong> documentation while solving a problem, post a link to the information that helped you in <strong>#compprogramming-docs</strong>, <strong>no matter how trivial</strong>. We’ll compile these links into printed documentation for competitions that do not allow Internet access.
    <h2>Updates</h2>
    <h3>Another competitive programming book</h3>
    <p class="lnum">In addition to <a href="https://cpbook.net"><i>Competitive Programming 3</i></a>, programming master Antti Laaksonen has recently published the <a href="https://cses.fi/book.pdf"><i>Competitive Programmer's Handbook</i></a>, a free 296-page ebook (more info at <a href="https://codeforces.com/blog/entry/50728">his blog post</a>), as well as an expanded version, the <a href="https://www.springer.com/us/book/9783319725468"><i>Guide to Competitive Programming</i></a> (ebook $39.99, softcover $49.99).
    <h3>More sites with practice problems</h3>
    <ul>
        <li><strong><a href="https://code-drills.com">Code Drills</a></strong> &ndash; Once you've completed some problems on <a href="https://codeforces.com" class="noprint">Codeforces</a>, <a href="https://codechef.com" class="noprint">CodeChef</a>, or <a href="https://www.spoj.com/problems/classical" class="noprint">Spoj</a>, enter your username(s) at Code Drills to be recommended new problems to solve based on the difficulty level of your previous solves! More info at <a href="https://codeforces.com/blog/entry/48991">Balajiganapathi's blog on Codeforces</a>.</li>
        <li><strong><a href="https://www.spoj.com/problems/classical/" data-href="https://spoj.com">Sphere Online Judge (Spoj)</a></strong> &ndash; Lots of problems with difficulty scores for both concept and implementation, and diverse language support.</li>
        <li><a href="https://cses.fi/problemset/">CSES Problem Set</a> &ndash; Problems with rankings for top 5 fastest and shortest programs &ndash; great for practicing your optimization and/or code golf. The usual languages are supported. <a href="https://cses.fi/register">Register at CSES</a> and log in to submit.</li>
        <li><a href="https://cses.fi/boi/list/">BOI Contest Collection</a> &ndash; Practice past problems from the Baltic Olympiad in Informatics, including a virtual contest option. <a href="https://cses.fi/register" class="noprint">Register at CSES</a> and log in to view problems and submit solutions.</li>
        <li><a href="https://cses.fi/ceoi/list/">CEOI Contest Collection</a> &ndash; Practice past problems from the Central European Olympiad in Informatics, including a virtual contest option. <a href="https://cses.fi/register" class="noprint">Register at CSES</a> and log in to view problems and submit solutions.</li>
        <li>The <a href="http://springcontest.cs.mercer.edu/">Mercer Spring Programming Contest</a> publishes their past solution sets. This is of particular interest to those of us competing there on <time datetime="2019-02-16">February 16</a>. We'll use the 2018 problems as practice at meetings in the coming weeks so don't do those!</li>
        <li><a href="https://community.topcoder.com/tc?module=ProblemArchive">Topcoder Problem Archive</a> &ndash; Problems from past Topcoder SRMs and TCO finals. Appears to be read-only. Also check their <a href="https://www.topcoder.com/?s=Editorials">post-contest editorials</a> for information on how to solve the problems!</li>
        <li><a href="https://codechef.com/INOIPRAC">INOI Practice Contest</a> &ndash; Practice problems for the Indian National Olympiad in Informatics hosted at CodeChef.</li>
        <li><a href="https://codechef.com/ZCOPRAC">ZCO Practice Contest</a> &ndash; Practice problems for the Zonal Computing Olympiad hosted at CodeChef.</li>
        <li><a href="https://contest.yandex.ru/ioi/">IOI Archive</a> &ndash; Past problems from the International Olympiad in Informatics hosted at Yandex Contest.</li>
    </ul>
    <h3>Upcoming competitions</h3>
    <ul>
        <li><strong>Happening now</strong> until <time datetime="2019-01-30T21:00:00.000-05:00"> Wednesday, January 30, 8:00 pm</time>: Topcoder Marathon Match 107</li>
        <li><time datetime="2019-01-26T08:00:00.000-06:00"><strong>Saturday, January 26</strong>, 8:00 am &ndash; 11:00 am</time>: <a href="https://www.codechef.com/LTIME68">CodeChef January Lunchtime 2019</a> (Individual, Online)</li>
        <li><time datetime="2019-01-26T12:00:00.000-05:00"><strong>Saturday, January 26</strong>, 11:00 am &ndash; 1:00 pm</time>: Topcoder SRM 748 (Individual, Online)</li>
        <li><time datetime="2019-01-31T06:30:00.000-06:00"><strong>Thursday, January 31</strong>, 6:30 am &ndash; 8:45 am</time>: <a href="https://codeforces.com/contests" class="noprint">Codeforces Round 535</a> (Individual, Online)</li>
        <li><time datetime="2019-02-16"><strong>Saturday, February 16</strong></time>: <a href="http://springcontest.cs.mercer.edu/" class="noprint">Mercer Spring Programming Contest</a> (Macon, GA, teams of 3) &ndash; <strong>three weeks away!</strong></li>
        <li><time datetime="2019-03-02T12:00:00.000-06:00"><strong>Saturday, March 2</strong>, noon &ndash; 5:00 pm</time>: <a href="http://naipc.uchicago.edu">North American Invitational Programming Contest</a> (Online, teams of 3)</li>
    </ul>

    <h2>Problems for this week</h2>
    <ul>
        <li><strong>Easy</strong>: Codeforces Problem 1097A (from Hello 2019) &ndash; <a href="https://codeforces.com/problemset/problem/1097/A" class="noprint">Gennady and a Card Game</a></li>
        <li><strong>Medium</strong>: Codeforces Problem 1105B (from Round 533) &ndash; <a href="https://codeforces.com/problemset/problem/1105/B" class="noprint">Zuhair and Strings</a></li>
        <li><strong>Hard</strong>: Codeforces Problem 774F (from VK Cup 2017) &ndash; <a href="https://codeforces.com/problemset/problem/774/F" class="noprint">Pens and Days of Week</a></li>
    </ul>

	<h2>Gennady and a Card Game</h2>
	<h3>Simplified problem description</h3>
	<p>Six standard playing cards are given. Each card is two characters: the first is the rank in <code>{'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}</code> and the second is the suit in <code>{'D', 'C', 'S', 'H'}</code>.
	<p>If any of the last five cards have the same rank or suit as the first card, print <code>"YES"</code>. Otherwise, print <code>"NO"</code>.
	<h3>Solutions</h3>
	<p>Since the algorithm for this one is pretty straightforward, I've implemented it in a few different languages to demonstrate the difference in runtimes that can become very significant for more complex problems:
	<p><strong>C++</strong>: <a href="/solutions/1097a.cpp">1097a.cpp</a> &ndash; this solution runs in <strong class="lnum">0.28 ms</strong> on my system and <span class="lnum">30 ms</span> (which seems to be the minimum with overhead) in Codeforces' environment.
	<pre>#include <iostream>
#include &lt;string&gt;

int main() {
    std::string tableCard;
    std::cin &gt;&gt; tableCard;
    for(int i = 0; i &lt; 5; i++) {
        std::string card;
        std::cin &gt;&gt; card;
        if(card[0] == tableCard[0] || card[1] == tableCard[1]) {
            std::cout &lt;&lt; "YES\n";
            return 0;
        }
    }
    std::cout &lt;&lt; "NO\n";
    return 0;
}</pre>
	<p><strong>C</strong>: <a href="/solutions/1097a.c">1097a.c</a> &ndash; this solution runs in <strong class="lnum">0.48 ms</strong> on my system and <span class="lnum">30 ms</span> in Codeforces' environment.
	<pre>#include &lt;stdio.h&gt;

int main() {
    char tableCard[2];
    scanf("%2s", tableCard);
    char card[2];
    for(int i = 0; i &lt; 5; i++) {
        scanf("%2s", card);
        if(card[0] == tableCard[0] || card[1] == tableCard[1]) {
            puts("YES");
            return 0;
        }
    }
    puts("NO");
    return 0;
}</pre>
	<p><strong>Python 3</strong>: <a href="/solutions/1097a.py">1097a.py</a> &ndash; this solution runs in <strong class="lnum">12.3 ms</strong> on my system and <span class="lnum">109 ms</span> in Codeforces' environment.
	<pre>tableCard = input()
cards = input().split(' ')
for card in cards:
    if card[0] == tableCard[0] or card[1] == tableCard[1]:
        print("YES")
        exit()
print("NO")</pre>
	<p><strong>Java</strong>: <a href="/solutions/Cardgame.java">Cardgame.java</a> &ndash; this solution runs in <strong class="lnum">80.6 ms</strong> on my system and <span class="lnum">124 ms</span> in Codeforces' environment.
	<pre>import java.util.Scanner;

public class Cardgame {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String tableCard = scanner.nextLine();
        String[] myCards = scanner.nextLine().split(" ");
        for(String card : myCards) {
            if(card.charAt(0) == tableCard.charAt(0) || card.charAt(1) == tableCard.charAt(1)) {
                System.out.println("YES");
                scanner.close();
                System.exit(0);
            }
        }
        System.out.println("NO");
        scanner.close();
        System.exit(0);
    }
}</pre>
	<p><strong>Brainfuck</strong>: This solution (annotated version: <a href="/solutions/1097a.bf">1097a.bf</a>) runs in <strong class="lnum">0.26 ms</strong> on my system (compiled with <a href="https://github.com/skeeto/bf-x86">bf-x86</a>) and is included here as evidence that <strong>C and C++ are not necessarily the fastest languages for a given problem</strong>. (Brainfuck lacks the overhead C and C++'s string implementations add in processing standard input.) If there's a language better suited to the problem that is supported by the contest, feel free use it! <i>Sadly, Codeforces does not support Brainfuck&mdash;but CodeChef does!</i>
	<pre>&gt;,&gt;,&lt;&lt;+++++&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++++[&gt;+++++++++++++&lt;-]&gt;[&gt;+&gt;+&gt;+&gt;+&gt;+&lt;&lt;&lt;&lt;&lt;-]+&gt;+++++++++++++++ +++++++++&gt;++++&gt;++++++++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;[-]&gt;[-]&lt;&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-],,&gt;,&lt;[ &lt;&lt;-&gt;&gt;-]&gt;&gt;+&lt;&lt;&lt;&lt;[&gt;&gt;&gt;[&lt;&lt;-&gt;&gt;-]&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;-&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;-]]&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt; &gt;&gt;&gt;&gt;-]&lt;[&gt;&gt;&gt;.&gt;.&gt;.&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;-&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;-]]&gt;&gt;&gt;&gt;&gt;[ &lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;[&gt;&gt;&gt;&gt;&gt;.&gt;.&gt;.&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[ &gt;&gt;&gt;&gt;.&gt;.&gt;.&lt;&lt;&lt;&lt;&lt;&lt;-]</pre>
	<h3>An object-oriented solution</h3>
	<p>Conventionally, better style would be to write something like the following (<a href="/solutions/1097a-oo.cpp">1097a-oo.cpp</a>):
	<pre>#include &lt;iostream&gt;

class Card {
public:
    bool operator==(const Card&amp; c) {
        return rank == c.rank || suit == c.suit;
    }
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Card&amp; c) {
        in &gt;&gt; c.rank &gt;&gt; c.suit;
    }
private:
    char rank, suit;
};

int main() {
    Card tableCard;
    std::cin &gt;&gt; tableCard;
    for(int i = 0; i &lt; 5; i++) {
        Card card;
        std::cin &gt;&gt; card;
        if(card == tableCard) {
            std::cout &lt;&lt; "YES\n";
            return 0;
        }
    }
    std::cout &lt;&lt; "NO\n";amp;
    return 0;
}
</pre>
	<p>But this is <strong>not good for competitive programming</strong>! It takes longer to write, there is more that can go wrong, and it takes about 28% longer to run (<span class="lnum">0.36 ms</span> on my system)! Remember, you aren't scored on style&mdash;only on how long it takes you to submit a solution that runs within the time and memory limits.

	<h2>Zuhair and Strings</h2>
	<h3>Using brute force</h3>
	<p>The strings are guaranteed to match <code>/^[a-z]+$/</code>, so there are only 26 possible characters that could yield the largest <i>x</i>. Furthermore, the string can be a maximum of 20,000 characters in length. This means that there are at most 520,000 possible combinations of character and starting position for a substring. Perhaps simply checking the string like this (<a href="/solutions/1105b-brute.cpp">1105b-brute.cpp</a>) will be good enough:
	<pre>#include &lt;iostream&gt;
#include &lt;string&gt;

using std::cin;
using std::cout;
using std::string;

int main() {
    int n, k;
    string s;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int level = 0;
    for(int i = 0; i &lt; 26; i++) {
        char c = 'a' + i;
        string sub = "";
        for(int x = 0; x &lt; k; x++) {
            sub += c;
        }
        int charLevel = 0;
        for(int j = 0; j &lt;= n - k * level + 1; j++) {
            int start = j;
            while(start &lt;= n - k * (level + 1) + 1) {
                if(s.substr(start, k) == sub) {
                    start += k;
                    charLevel++;
                }
                else {
                    start++;
                }
            }
            if(charLevel &gt; level) level = charLevel;
            charLevel = 0;
        }
    }
    cout &lt;&lt; level &lt;&lt; '\n';
}
</pre>
	<p>Unfortunately, when given <a href="strings.in">a particularly troubling input</a> (generated with <a href="strings.py">strings.py</a>), this program takes <strong class="lnum">8.25 seconds</strong> to complete on my system&mdash;well over the 1-second time limit.

    <h2>Pens and Days of Week</h2>

    <h3>Simplified problem description</h3>
    <p class="lnum">Provided is an array <code>a</code> of <code>n</code> integers.
    <br>Every day <code>x</code> (starting from day 0), <code>a[x % n] -= 1</code>, except when <code>x % 7 == 6</code>.
    <br>What is the index of the first value in <code>a</code> to reach 0?
    <br>1 &le; <code>n</code> &le; 50,000; 1 &le; <code>a[i]</code> &le; 10&#x2079;</code>
    <br>Input format: <code>n</code> on first line, then space-separated <code>a[i]</code> on second line.
    <br>Output format: The index of the solution plus 1 (since the problem uses a 1-indexed array of pens).
    <br>Time limit: 3 seconds; memory limit: 256 MB.

    <h3>Na&iuml;ve solution</h3>
    <p>At first, this problem may appear easy. It is tempting to write something like the following (<a href="/solutions/pens-naive.cpp">pens-naive.cpp</a>):
    <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    int n;
    std::vector&lt;int&gt; a;
    std::cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        int val;
        std::cin &gt;&gt; val;
        a.push_back(val);
    }
    int x = 0;
    while(true) {
        if(x % 7 != 6) a[x % n]--;
        if(a[x % n] == 0) {
            std::cout &lt;&lt; x % n + 1 &lt;&lt; std::endl;
            break;
        }
        x++;
    }
    return 0;
}</pre>

	<p><strong>This isn't good enough.</strong> Though this program should always produce the correct answer, it is not nearly efficient enough to process the maximum input. For the two sample cases, it completes in 2 ms on my system&mdash;pretty good, right?&mdash;but when given the <a href="pens.in">maximal input file</a> (50,000 pens each with 1,000,000,000 ml of ink; input file generated with <a href="pens.py">pens.py</a>), it segfaulted because <code>x</code> did not have enough bytes. After changing <code>x</code> to an <code>unsigned long long int</code> and adding some signal handling (see: <a href="pens-naive-modified.cpp">pens-naive-modified.cpp</a>), I estimated based on the <a href="pens.1h">state after one hour</a> that this algorithm would complete on my system in <strong class="lnum">10 days, 13 hours, and 18 minutes</strong>.

	<p>That is more than three seconds.

	<h3>Analyzing the problem</h3>
	<p>At this point, I made tables to show the state of the array in the na&iuml;ve solution after each day for each sample input:
	<div style="width: 100%; text-align: right;">
		<div style="float: left; max-width: 50%;">
			<table style="margin-top: 0; margin-left: 0;">
				<thead>
					<tr><th rowspan="2">Sample 1</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th></tr>
					<tr><th style="border: none;"><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th></tr>
				</thead>
				<tbody>
					<tr><th>Start</td><td>3</td><td>3</td><td>3</td></tr>
					<tr><th>After day 0</th><td class="highlight">2</td><td>3</td><td>3</td></tr>
					<tr><th>After day 1</th><td>2</td><td class="highlight">2</td><td>3</td></tr>
					<tr><th>After day 2</th><td>2</td><td>2</td><td class="highlight">2</td></tr>
					<tr><th>After day 3</th><td class="highlight">1</td><td>2</td><td>2</td></tr>
					<tr><th>After day 4</th><td>1</td><td class="highlight">1</td><td>2</td></tr>
					<tr><th>After day 5</th><td>1</td><td>1</td><td class="highlight">1</td></tr>
					<tr><th><strong>After day 6</strong></th><td class="highlight">1</td><td>1</td><td>1</td></tr>
					<tr><th>After day 7</th><td>1</td><td class="highlight"><strong>0</strong></td><td>1</td></tr>
				</tbody>
			</table>
			<p style="font-style: italic; text-align: left;">In these tables, the value that is decremented on each day is highlighted; days on which this value is <strong>not</strong> decremented (Sundays) are listed in bold in the left column. The first value equal to zero is bolded. Days are zero-indexed as in the above implementation despite being one-indexed in the problem statement; both indices are presented for the pen numbers in the header rows.
		</div>
		<div style="display: inline-block; max-width: 50%;">
			<table style="margin-top: 0; margin-right: 0;">
				<thead>
					<tr><th rowspan="2">Sample 2</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th><th>Pen 4</th><th>Pen 5</th></tr>
					<tr><th style="border: none;"><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th><th><code>a[3]</code></th><th><code>a[4]</code></th></tr>
				</thead>
				<tbody>
					<tr><th>Start</td><td>5</td><td>4</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 0</th><td class="highlight">4</td><td>4</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 1</th><td>4</td><td class="highlight">3</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 2</th><td>4</td><td>3</td><td class="highlight">4</td><td>4</td><td>4</td></tr>
					<tr><th>After day 3</th><td>4</td><td>3</td><td>4</td><td class="highlight">3</td><td>4</td></tr>
					<tr><th>After day 4</th><td>4</td><td>3</td><td>4</td><td>3</td><td class="highlight">3</td></tr>
					<tr><th>After day 5</th><td class="highlight">3</td><td>3</td><td>4</td><td>3</td><td>3</td></tr>
					<tr><th><strong>After day 6</strong></th><td>3</td><td class="highlight">3</td><td>4</td><td>3</td><td>3</td></tr>
					<tr><th>After day 7</th><td>3</td><td>3</td><td class="highlight">3</td><td>3</td><td>3</td></tr>
					<tr><th>After day 8</th><td>3</td><td>3</td><td>3</td><td class="highlight">2</td><td>3</td></tr>
					<tr><th>After day 9</th><td>3</td><td>3</td><td>3</td><td>2</td><td class="highlight">2</td></tr>
					<tr><th>After day 10</th><td class="highlight">2</td><td>3</td><td>3</td><td>2</td><td>2</td></tr>
					<tr><th>After day 11</th><td>2</td><td class="highlight">2</td><td>3</td><td>2</td><td>2</td></tr>
					<tr><th>After day 12</th><td>2</td><td>2</td><td class="highlight">2</td><td>2</td><td>2</td></tr>
					<tr><th><strong>After day 13</strong></th><td>2</td><td>2</td><td>2</td><td class="highlight">2</td><td>2</td></tr>
					<tr><th>After day 14</th><td>2</td><td>2</td><td>2</td><td>2</td><td class="highlight">1</td></tr>
					<tr><th>After day 15</th><td class="highlight">1</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
					<tr><th>After day 16</th><td>1</td><td class="highlight">1</td><td>2</td><td>2</td><td>1</td></tr>
					<tr><th>After day 17</th><td>1</td><td>1</td><td class="highlight">1</td><td>2</td><td>1</td></tr>
					<tr><th>After day 18</th><td>1</td><td>1</td><td>1</td><td class="highlight">1</td><td>1</td></tr>
					<tr><th>After day 19</th><td>1</td><td>1</td><td>1</td><td>1</td><td class="highlight"><strong>0</strong></td></tr>
				</tbody>
			</table>
		</div>
	</div>

	<p><strong>Tip: Always try to calculate the sample inputs on paper to make sure you understand the problem correctly!</strong> You may even stumble into an efficient solution in the process. I spent some time at last week's meeting trying to figure out why my program wasn't working before realizing my algorithm was based on an incorrect interpretation of the problem statement.

	<p>After completing the above tables, I noticed that the pattern in the ink values was more obvious for each pen than for each day. Take pen 4 in sample 2, for instance. It starts with 4 ml of ink. This is then decremented on day 5<i>n</i> + 3 (n ∈ <b>Z</b>), except when <code>day % 7 == 6</code>. The following algorithm (<a href="/solutions/pens-vertical.cpp">pens-vertical.cpp</a>) naturally arises from this observation:

<pre>#include &lt;iostream&gt;
#include &lt;climits&gt;

int main() {
    int n;
    unsigned long long int minDay = ULLONG_MAX;
    int minPen = 0;
    std::cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        int ink;
        std::cin &gt;&gt; ink;

        unsigned long long int day = i;
        for(;;) {
            if(day % 7 == 6) {
                day += n;
                if(day % 7 == 6) {
                    break; // pen is never used
                }
            }
            ink--;
            if(day &gt;= minDay) {
                break; // pen is not the first to run out of ink
            }
            if(!ink) {
                minDay = day;
                minPen = i;
                break; // pen ran out of ink
            }
            day += n;
        }
    }
    std::cout &lt;&lt; minPen + 1 &lt;&lt; '\n';
    return 0;
}</pre>

	<p>Guess what? <strong>This isn't good enough either.</strong> If it is billions of days before a pen runs out of ink, there are still millions of calculations to be done on each pen. I again <a href="pens-vertical-modified.cpp">modified this program</a> to report the <a href="pens-vert.1h">state after one hour</a> and used this data to estimate that this program would complete in <strong class="lnum">22 hours and 15 minutes</strong> on my system&mdash;much faster than the first algorithm, but still more than 3 seconds.

	<h3>Optimizing the above algorithm</h3>
	<p>This algorithm certainly <em>feels</em> nicer than the first one (to me, anyway)&mdash;the calculations it's doing are much more straightforward, but there are still too many of them.
	<p>How can we determine the day on which each pen runs out of ink mathematically rather than with brute force?

	<h3>Another idea</h3>
	<p>What if we combined days into blocks such that each pen's ink is decreased by the same amount in each row of the table? In order to see the benefit of this, we'll need to come up with a new example. The table below corresponds to the following input:
	<pre>5<br>14 14 14 14 13</pre>
	<div style="width: 100%; text-align: right;">
		<div style="float: left; max-width: 50%;">
			<table style="margin: 0;">
				<thead>
					<tr><th rowspan="2">Sample 2</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th><th>Pen 4</th><th>Pen 5</th></tr>
					<tr><th><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th><th><code>a[3]</code></th><th><code>a[4]</code></th></tr>
				</thead>
				<tbody>
				    <tr><th>Start</th><td>14</td><td>14</td><td>14</td><td>14</td><td>13</td></tr>
					<tr><th colspan="6" style="font-weight: bold; text-align: center; padding-top: 0.5em;">Days 0&ndash;34</th></tr>
				    <tr><th>After day 0</th><td class="highlight">13</td><td>14</td><td>14</td><td>14</td><td>13</td></tr>
				    <tr><th>After day 1</th><td>13</td><td class="highlight">13</td><td>14</td><td>14</td><td>13</td></tr>
				    <tr><th>After day 2</th><td>13</td><td>13</td><td class="highlight">13</td><td>14</td><td>13</td></tr>
				    <tr><th>After day 3</th><td>13</td><td>13</td><td>13</td><td class="highlight">13</td><td>13</td></tr>
				    <tr><th>After day 4</th><td>13</td><td>13</td><td>13</td><td>13</td><td class="highlight">12</td></tr>
				    <tr><th>After day 5</th><td class="highlight">12</td><td>13</td><td>13</td><td>13</td><td>12</td></tr>
				    <tr><th><strong>After day 6</strong></th><td>12</td><td class="highlight">13</td><td>13</td><td>13</td><td>12</td></tr>
				    <tr><th>After day 7</th><td>12</td><td>13</td><td class="highlight">12</td><td>13</td><td>12</td></tr>
				    <tr><th>After day 8</th><td>12</td><td>13</td><td>12</td><td class="highlight">12</td><td>12</td></tr>
				    <tr><th>After day 9</th><td>12</td><td>13</td><td>12</td><td>12</td><td class="highlight">11</td></tr>
				    <tr><th>After day 10</th><td class="highlight">11</td><td>13</td><td>12</td><td>12</td><td>11</td></tr>
				    <tr><th>After day 11</th><td>11</td><td class="highlight">12</td><td>12</td><td>12</td><td>11</td></tr>
				    <tr><th>After day 12</th><td>11</td><td>12</td><td class="highlight">11</td><td>12</td><td>11</td></tr>
				    <tr><th><strong>After day 13</strong></th><td>11</td><td>12</td><td>11</td><td class="highlight">12</td><td>11</td></tr>
				    <tr><th>After day 14</th><td>11</td><td>12</td><td>11</td><td>12</td><td class="highlight">10</td></tr>
				    <tr><th>After day 15</th><td class="highlight">10</td><td>12</td><td>11</td><td>12</td><td>10</td></tr>
				    <tr><th>After day 16</th><td>10</td><td class="highlight">11</td><td>11</td><td>12</td><td>10</td></tr>
				    <tr><th>After day 17</th><td>10</td><td>11</td><td class="highlight">10</td><td>12</td><td>10</td></tr>
				    <tr><th>After day 18</th><td>10</td><td>11</td><td>10</td><td class="highlight">11</td><td>10</td></tr>
				    <tr><th>After day 19</th><td>10</td><td>11</td><td>10</td><td>11</td><td class="highlight">9</td></tr>
				    <tr><th><strong>After day 20</strong></th><td class="highlight">10</td><td>11</td><td>10</td><td>11</td><td>9</td></tr>
				    <tr><th>After day 21</th><td>10</td><td class="highlight">10</td><td>10</td><td>11</td><td>9</td></tr>
				    <tr><th>After day 22</th><td>10</td><td>10</td><td class="highlight">9</td><td>11</td><td>9</td></tr>
				    <tr><th>After day 23</th><td>10</td><td>10</td><td>9</td><td class="highlight">10</td><td>9</td></tr>
				    <tr><th>After day 24</th><td>10</td><td>10</td><td>9</td><td>10</td><td class="highlight">8</td></tr>
				    <tr><th>After day 25</th><td class="highlight">9</td><td>10</td><td>9</td><td>10</td><td>8</td></tr>
				    <tr><th>After day 26</th><td>9</td><td class="highlight">9</td><td>9</td><td>10</td><td>8</td></tr>
				    <tr><th><strong>After day 27</strong></th><td>9</td><td>9</td><td class="highlight">9</td><td>10</td><td>8</td></tr>
				    <tr><th>After day 28</th><td>9</td><td>9</td><td>9</td><td class="highlight">9</td><td>8</td></tr>
				    <tr><th>After day 29</th><td>9</td><td>9</td><td>9</td><td>9</td><td class="highlight">7</td></tr>
				    <tr><th>After day 30</th><td class="highlight">8</td><td>9</td><td>9</td><td>9</td><td>7</td></tr>
				    <tr><th>After day 31</th><td>8</td><td class="highlight">8</td><td>9</td><td>9</td><td>7</td></tr>
				    <tr><th>After day 32</th><td>8</td><td>8</td><td class="highlight">8</td><td>9</td><td>7</td></tr>
				    <tr><th>After day 33</th><td>8</td><td>8</td><td>8</td><td class="highlight">8</td><td>7</td></tr>
				    <tr><th><strong>After day 34</strong></th><td>8</td><td>8</td><td>8</td><td>8</td><td class="highlight">7</td></tr>
					<tr><th colspan="6" style="font-weight: bold; font-style: italic; text-align: center; padding-top: 0.5em;">Continued on right</th></tr>
				</tbody>
			</table>
			<p style="font-style: italic; text-align: left;">This could be displayed as a very wide table, each row consisting of one block of days, but it wouldn't fit on this page.
		</div>
		<div style="display: inline-block; max-width: 50%;">
			<table style="margin: 0;">
				<thead>
					<tr><th rowspan="2">Sample 2<br>(continued)</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th><th>Pen 4</th><th>Pen 5</th></tr>
					<tr><th><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th><th><code>a[3]</code></th><th><code>a[4]</code></th></tr>
				</thead>
				<tbody>
				    <tr><th>After day 34</th><td>8</td><td>8</td><td>8</td><td>8</td><td>7</td></tr>
					<tr><th colspan="6" style="font-weight: bold; text-align: center; padding-top: 0.5em;">Days 35&ndash;69</th></tr>
				    <tr><th>After day 35</th><td class="highlight">7</td><td>8</td><td>8</td><td>8</td><td>7</td></tr>
				    <tr><th>After day 36</th><td>7</td><td class="highlight">7</td><td>8</td><td>8</td><td>7</td></tr>
				    <tr><th>After day 37</th><td>7</td><td>7</td><td class="highlight">7</td><td>8</td><td>7</td></tr>
				    <tr><th>After day 38</th><td>7</td><td>7</td><td>7</td><td class="highlight">7</td><td>7</td></tr>
				    <tr><th>After day 39</th><td>7</td><td>7</td><td>7</td><td>7</td><td class="highlight">6</td></tr>
				    <tr><th>After day 40</th><td class="highlight">6</td><td>7</td><td>7</td><td>7</td><td>6</td></tr>
				    <tr><th><strong>After day 41</strong></th><td>6</td><td class="highlight">7</td><td>7</td><td>7</td><td>6</td></tr>
				    <tr><th>After day 42</th><td>6</td><td>7</td><td class="highlight">6</td><td>7</td><td>6</td></tr>
				    <tr><th>After day 43</th><td>6</td><td>7</td><td>6</td><td class="highlight">6</td><td>6</td></tr>
				    <tr><th>After day 44</th><td>6</td><td>7</td><td>6</td><td>6</td><td class="highlight">5</td></tr>
				    <tr><th>After day 45</th><td class="highlight">5</td><td>7</td><td>6</td><td>6</td><td>5</td></tr>
				    <tr><th>After day 46</th><td>5</td><td class="highlight">6</td><td>6</td><td>6</td><td>5</td></tr>
				    <tr><th>After day 47</th><td>5</td><td>6</td><td class="highlight">5</td><td>6</td><td>5</td></tr>
				    <tr><th><strong>After day 48</strong></th><td>5</td><td>6</td><td>5</td><td class="highlight">6</td><td>5</td></tr>
				    <tr><th>After day 49</th><td>5</td><td>6</td><td>5</td><td>6</td><td class="highlight">4</td></tr>
				    <tr><th>After day 50</th><td class="highlight">4</td><td>6</td><td>5</td><td>6</td><td>4</td></tr>
				    <tr><th>After day 51</th><td>4</td><td class="highlight">5</td><td>5</td><td>6</td><td>4</td></tr>
				    <tr><th>After day 52</th><td>4</td><td>5</td><td class="highlight">4</td><td>6</td><td>4</td></tr>
				    <tr><th>After day 53</th><td>4</td><td>5</td><td>4</td><td class="highlight">5</td><td>4</td></tr>
				    <tr><th>After day 54</th><td>4</td><td>5</td><td>4</td><td>5</td><td class="highlight">3</td></tr>
				    <tr><th><strong>After day 55</strong></th><td class="highlight">4</td><td>5</td><td>4</td><td>5</td><td>3</td></tr>
				    <tr><th>After day 56</th><td>4</td><td class="highlight">4</td><td>4</td><td>5</td><td>3</td></tr>
				    <tr><th>After day 57</th><td>4</td><td>4</td><td class="highlight">3</td><td>5</td><td>3</td></tr>
				    <tr><th>After day 58</th><td>4</td><td>4</td><td>3</td><td class="highlight">4</td><td>3</td></tr>
				    <tr><th>After day 59</th><td>4</td><td>4</td><td>3</td><td>4</td><td class="highlight">2</td></tr>
				    <tr><th>After day 60</th><td class="highlight">3</td><td>4</td><td>3</td><td>4</td><td>2</td></tr>
				    <tr><th>After day 61</th><td>3</td><td class="highlight">3</td><td>3</td><td>4</td><td>2</td></tr>
				    <tr><th><strong>After day 62</strong></th><td>3</td><td>3</td><td class="highlight">3</td><td>4</td><td>2</td></tr>
				    <tr><th>After day 63</th><td>3</td><td>3</td><td>3</td><td class="highlight">3</td><td>2</td></tr>
				    <tr><th>After day 64</th><td>3</td><td>3</td><td>3</td><td>3</td><td class="highlight">1</td></tr>
				    <tr><th>After day 65</th><td class="highlight">2</td><td>3</td><td>3</td><td>3</td><td>1</td></tr>
				    <tr><th>After day 66</th><td>2</td><td class="highlight">2</td><td>3</td><td>3</td><td>1</td></tr>
				    <tr><th>After day 67</th><td>2</td><td>2</td><td class="highlight">2</td><td>3</td><td>1</td></tr>
				    <tr><th>After day 68</th><td>2</td><td>2</td><td>2</td><td class="highlight">2</td><td>1</td></tr>
				    <tr><th><strong>After day 69</strong></th><td>2</td><td>2</td><td>2</td><td>2</td><td class="highlight">1</td></tr>
					<tr><th colspan="6" style="font-weight: bold; text-align: center; padding-top: 0.5em;">Days 70&ndash;104</th></tr>
				    <tr><th>After day 70</th><td class="highlight">1</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
				    <tr><th>After day 71</th><td>1</td><td class="highlight">1</td><td>2</td><td>2</td><td>1</td></tr>
				    <tr><th>After day 72</th><td>1</td><td>1</td><td class="highlight">1</td><td>2</td><td>1</td></tr>
				    <tr><th>After day 73</th><td>1</td><td>1</td><td>1</td><td class="highlight">1</td><td>1</td></tr>
				    <tr><th>After day 74</th><td>1</td><td>1</td><td>1</td><td>1</td><td class="highlight">0</td></tr>
				</tbody>
			</table>
		</div>
	</div>

	<p>In this example, after each block of 35 days, each pen's ink level is decreased by 6. Why? Because the width of the block is <code>7 * n</code>, so each day of the week except Sunday sees each pen decremented once during the block. <strong>The result will always be 6 if <code>n % 7 != 0</code>.</strong>

	<p>The other case is of course when <code>n % 7 == 0</code>. In this case, the pattern becomes much simpler: some pens (those with indices <code>i % 7 == 6</code>) are <em>never</em> decremented, and the others are decremented once per block.

	<p>The length of these blocks (lcm(7, <i>n</i>) days) turns out to be irrelevant&mdash;what matters is now how many <em>blocks</em>, not how many <em>days</em>, it takes for each pen to run out of ink. This calculation is simple!
	<pre>int endBlocks[n] = {0}; // The block in which pen n runs out of ink.
for(int i = 0; i < n; i++) {
    if(i % 7 == 6) endBlocks[n] = -1; // The pen never runs out of ink.
    else endBlocks[n] = a[n] / 6 + !!(a[n] % 6); // A safe implementation of ceil(a[n] / 6)
}</pre>

 	<p>But how do we know which pen runs out of ink first if two pens run out in the same block? It's not guaranteed to be the pen with the lowest index that runs out during this block, since that pen could be used on Sunday before another pen runs out in the following week within the same block. Because blocks always end on Sunday, it is sufficient for our needs to simply skip to the beginning of the first block in which a pen runs out of ink, then run the na&iuml;ve algorithm (<a href="pens.cpp">pens.cpp</a>):

	<pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;

int main() {
    int n;
    std::cin &gt;&gt; n;
    int ink[n];
    int minBlock = INT_MAX;
    for(int i = 0; i &lt; n; i++) {
        std::cin &gt;&gt; ink[i];
        int endBlock = -1; // -1 if this pen is never depleted
        if(n % 7) {
            endBlock = ink[i] / 6 + !!(ink[i] % 6) - 1; // Block before this pen runs out of ink
        }
        else {
            if(i % 7 != 6) {
                endBlock = ink[i] - 1;
            }
        }
        if(endBlock != -1 &amp;&amp; endBlock &lt; minBlock) {
            minBlock = endBlock;
        }
    }

    // Determine the state at the end of the minBlock.
    for(int i = 0; i &lt; n; i++) {
        if(n % 7) {
            ink[i] -= minBlock * 6;
        }
        else {
            if(i % 7 != 6) {
                ink[i] -= minBlock;
            }
        }
    }

    // Calculate from the beginning of the minBlock.
    int minDay = INT_MAX;
    int minPen = 0;
    for(int i = 0; i &lt; n; i++) {
        int a = ink[i];
        int day = i;
        for(;;) {
            if(day % 7 == 6) {
                day += n;
                if(day % 7 == 6) {
                    break; // pen is never used
                }
            }
            a--;
            if(day &gt;= minDay) {
                break; // pen is not the first to run out of ink
            }
            if(!a) {
                minDay = day;
                minPen = i;
                break; // pen ran out of ink
            }
            day += n;
        }
    }
    std::cout &lt;&lt; minPen + 1 &lt;&lt; '\n';
    return 0;
}</pre>

	<p>This solution runs in <strong class="lnum">27 ms</strong> on my machine and <span class="lnum">124 ms</span> in Codeforces' environment.

	<p>It would also be acceptable to use the first na&iuml;ve algorithm for the final stage (<a href="/solutions/pens-using-naive.cpp">pens-using-naive.cpp</a>). This solution takes almost exactly the same amount of time since there is very little to be done in this final loop.

	<p>Of course, we could also find a more efficient algorithm to determine which pen runs out first in the final block. But we do not need to.
</article>
