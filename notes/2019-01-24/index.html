<!DOCTYPE html>

<title>Competitive Programming - January 24, 2019</title>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="/notes/notes.css">

<header>
    <h1>Competitive Programming</h1>
    <time datetime="2019-01-24">January 24, 2019</time>
</header>

<article>
    <p>
    Reminder: when you google <strong>anything</strong> or refer to <strong>any</strong> documentation while solving a problem, post a link to the information that helped you in <strong>#compprogramming-docs</strong>, <strong>no matter how trivial</strong>. We’ll compile these links into printed documentation for competitions that do not allow Internet access.
    <h2>Updates</h2>
    <h3>Another competitive programming book</h3>
    <p class="lnum">In addition to <a href="https://cpbook.net"><i>Competitive Programming 3</i></a>, programming master Antti Laaksonen has recently published the <a href="https://cses.fi/book.pdf"><i>Competitive Programmer's Handbook</i></a>, a free 296-page ebook (more info at <a href="https://codeforces.com/blog/entry/50728">his blog post</a>), as well as an expanded version, the <a href="https://www.springer.com/us/book/9783319725468"><i>Guide to Competitive Programming</i></a> (ebook $39.99, softcover $49.99).
    <h3>More sites with practice problems</h3>
    <ul>
        <li><strong><a href="https://code-drills.com">Code Drills</a></strong> &ndash; Once you've completed some problems on <a href="https://codeforces.com" class="noprint">Codeforces</a>, <a href="https://codechef.com" class="noprint">CodeChef</a>, or <a href="https://www.spoj.com/problems/classical" class="noprint">Spoj</a>, enter your username(s) at Code Drills to be recommended new problems to solve based on the difficulty level of your previous solves! More info at <a href="https://codeforces.com/blog/entry/48991">Balajiganapathi's blog on Codeforces</a>.</li>
        <li><strong><a href="https://www.spoj.com/problems/classical/" data-href="https://spoj.com">Sphere Online Judge (Spoj)</a></strong> &ndash; Lots of problems with difficulty scores for both concept and implementation, and diverse language support.</li>
        <li><a href="https://cses.fi/problemset/">CSES Problem Set</a> &ndash; Problems with rankings for top 5 fastest and shortest programs &ndash; great for practicing your optimization and/or code golf. The usual languages are supported. <a href="https://cses.fi/register">Register at CSES</a> and log in to submit.</li>
        <li><a href="https://cses.fi/boi/list/">BOI Contest Collection</a> &ndash; Practice past problems from the Baltic Olympiad in Informatics, including a virtual contest option. <a href="https://cses.fi/register" class="noprint">Register at CSES</a> and log in to view problems and submit solutions.</li>
        <li><a href="https://cses.fi/ceoi/list/">CEOI Contest Collection</a> &ndash; Practice past problems from the Central European Olympiad in Informatics, including a virtual contest option. <a href="https://cses.fi/register" class="noprint">Register at CSES</a> and log in to view problems and submit solutions.</li>
        <li>The <a href="http://springcontest.cs.mercer.edu/">Mercer Spring Programming Contest</a> publishes their past solution sets. This is of particular interest to those of us competing there on <time datetime="2019-02-16">February 16</a>. We'll use the 2018 problems as practice at meetings in the coming weeks so don't do those!</li>
        <li><a href="https://community.topcoder.com/tc?module=ProblemArchive">Topcoder Problem Archive</a> &ndash; Problems from past Topcoder SRMs and TCO finals. Appears to be read-only. Also check their <a href="https://www.topcoder.com/?s=Editorials">post-contest editorials</a> for information on how to solve the problems!</li>
        <li><a href="https://codechef.com/INOIPRAC">INOI Practice Contest</a> &ndash; Practice problems for the Indian National Olympiad in Informatics hosted at CodeChef.</li>
        <li><a href="https://codechef.com/ZCOPRAC">ZCO Practice Contest</a> &ndash; Practice problems for the Zonal Computing Olympiad hosted at CodeChef.</li>
        <li><a href="https://contest.yandex.ru/ioi/">IOI Archive</a> &ndash; Past problems from the International Olympiad in Informatics hosted at Yandex Contest.</li>
    </ul>
    <h3>Upcoming competitions</h3>
    <ul>
        <li><strong>Happening now</strong> until <time datetime="2019-01-30T21:00:00.000-05:00"> Wednesday, January 30, 8:00 pm</time>: Topcoder Marathon Match 107</li>
        <li><time datetime="2019-01-26T08:00:00.000-06:00"><strong>Saturday, January 26</strong>, 8:00 am &ndash; 11:00 am</time>: <a href="https://www.codechef.com/LTIME68">CodeChef January Lunchtime 2019</a> (Individual, Online)</li>
        <li><time datetime="2019-01-26T12:00:00.000-05:00"><strong>Saturday, January 26</strong>, 11:00 am &ndash; 1:00 pm</time>: Topcoder SRM 748 (Individual, Online)</li>
        <li><time datetime="2019-01-31T06:30:00.000-06:00"><strong>Thursday, January 31</strong>, 6:30 am &ndash; 8:45 am</time>: <a href="https://codeforces.com/contests" class="noprint">Codeforces Round 535</a> (Individual, Online)</li>
        <li><time datetime="2019-02-16"><strong>Saturday, February 16</strong></time>: <a href="http://springcontest.cs.mercer.edu/" class="noprint">Mercer Spring Programming Contest</a> (Macon, GA, teams of 3) &ndash; <strong>three weeks away!</strong></li>
        <li><time datetime="2019-03-02T12:00:00.000-06:00"><strong>Saturday, March 2</strong>, noon &ndash; 5:00 pm</time>: <a href="http://naipc.uchicago.edu">North American Invitational Programming Contest</a> (Online, teams of 3)</li>
    </ul>

    <h2>Problems for this week</h2>
    <ul>
        <li><strong>Easy</strong>: </li>
        <li><strong>Medium</strong>: </li>
        <li><strong>Hard</strong>: Codeforces Problem 774F (from VK Cup 2017) &ndash; <a href="https://codeforces.com/problemset/problem/774/F" class="noprint">Pens and Days of Week</a></li>
    </ul>

    <h2>Pens and Days of Week</h2>
    <p>I spent a couple hours at last week's meeting going down an incorrect path for this problem. Hopefully we can figure it out this week.

    <h3>Simplified problem description</h3>
    <p class="lnum">Provided is an array <code>a</code> of <code>n</code> integers.
    <br>Every day <code>x</code> (starting from day 0), <code>a[x % n] -= 1</code>, except when <code>x % 7 == 6</code>.
    <br>What is the index of the first value in <code>a</code> to reach 0?
    <br>1 &le; <code>n</code> &le; 50,000; 1 &le; <code>a[i]</code> &le; 10&#x2079;</code>
    <br>Input format: <code>n</code> on first line, then space-separated <code>a[i]</code> on second line.
    <br>Output format: The index of the solution plus 1 (since the problem uses a 1-indexed array of pens).
    <br>Time limit: 3 seconds; memory limit: 256 MB.

    <h3>Na&iuml;ve solution</h3>
    <p>At first, this problem may appear easy. It is tempting to write something like the following (<a href="/solutions/pens-naive.cpp">pens-naive.cpp</a>):
    <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    int n;
    std::vector&lt;int&gt; a;
    std::cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        int val;
        std::cin &gt;&gt; val;
        a.push_back(val);
    }
    int x = 0;
    while(true) {
        if(x % 7 != 6) a[x % n]--;
        if(a[x % n] == 0) {
            std::cout &lt;&lt; x % n + 1 &lt;&lt; std::endl;
            break;
        }
        x++;
    }
    return 0;
}</pre>

	<p><strong>This isn't good enough.</strong> Though the solution is correct (it always produces the correct answer, I think), it is not nearly efficient enough to process the maximum input. For the two sample cases, it completes in 2 ms on my system&mdash;pretty good, right?&mdash;but when given the <a href="pens.in">maximal input file</a> (50,000 pens each with 1,000,000,000 ml of ink; input file generated with <a href="pens.py">pens.py</a>), it segfaulted because <code>x</code> did not have enough bytes. After changing <code>x</code> to an <code>unsigned long long int</code> and adding some signal handling (see: <a href="pens-naive-modified.cpp">pens-naive-modified.cpp</a>), I estimated based on the <a href="pens.1h">state after one hour</a> that this algorithm would complete on my system in <strong>10 days, 13 hours, and 18 minutes</strong>.

	<p>That is more than three seconds.

	<h3>Analyzing the problem</h3>
	<p>At this point, I made tables to show the state of the array in the na&iuml;ve solution after each day for each sample input:
	<div style="position: relative; width: 100%; text-align: right;">
		<div style="float: left; max-width: 50%;">
			<table style="margin-top: 0; margin-left: 0;">
				<thead>
					<tr><th rowspan="2">Sample 1</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th></tr>
					<tr><th style="border: none;"><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th></tr>
				</thead>
				<tbody>
					<tr><th>Start</td><td>3</td><td>3</td><td>3</td></tr>
					<tr><th>After day 0</th><td class="highlight">2</td><td>3</td><td>3</td></tr>
					<tr><th>After day 1</th><td>2</td><td class="highlight">2</td><td>3</td></tr>
					<tr><th>After day 2</th><td>2</td><td>2</td><td class="highlight">2</td></tr>
					<tr><th>After day 3</th><td class="highlight">1</td><td>2</td><td>2</td></tr>
					<tr><th>After day 4</th><td>1</td><td class="highlight">1</td><td>2</td></tr>
					<tr><th>After day 5</th><td>1</td><td>1</td><td class="highlight">1</td></tr>
					<tr><th><strong>After day 6</strong></th><td class="highlight">1</td><td>1</td><td>1</td></tr>
					<tr><th>After day 7</th><td>1</td><td class="highlight"><strong>0</strong></td><td>1</td></tr>
				</tbody>
			</table>
			<p style="font-style: italic; text-align: left;">In these tables, the value that is decremented on each day is highlighted; days on which this value is <strong>not</strong> decremented (Sundays) are listed in bold in the left column. The first value equal to zero is bolded. Days are zero-indexed as in the above implementation despite being one-indexed in the problem statement; both indices are presented for the pen numbers in the header rows.
		</div>
		<div style="display: inline-block; max-width: 50%;">
			<table style="margin-top: 0; margin-right: 0;">
				<thead>
					<tr><th rowspan="2">Sample 2</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th><th>Pen 4</th><th>Pen 5</th></tr>
					<tr><th style="border: none;"><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th><th><code>a[3]</code></th><th><code>a[4]</code></th></tr>
				</thead>
				<tbody>
					<tr><th>Start</td><td>5</td><td>4</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 0</th><td class="highlight">4</td><td>4</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 1</th><td>4</td><td class="highlight">3</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 2</th><td>4</td><td>3</td><td class="highlight">4</td><td>4</td><td>4</td></tr>
					<tr><th>After day 3</th><td>4</td><td>3</td><td>4</td><td class="highlight">3</td><td>4</td></tr>
					<tr><th>After day 4</th><td>4</td><td>3</td><td>4</td><td>3</td><td class="highlight">3</td></tr>
					<tr><th>After day 5</th><td class="highlight">3</td><td>3</td><td>4</td><td>3</td><td>3</td></tr>
					<tr><th><strong>After day 6</strong></th><td>3</td><td class="highlight">3</td><td>4</td><td>3</td><td>3</td></tr>
					<tr><th>After day 7</th><td>3</td><td>3</td><td class="highlight">3</td><td>3</td><td>3</td></tr>
					<tr><th>After day 8</th><td>3</td><td>3</td><td>3</td><td class="highlight">2</td><td>3</td></tr>
					<tr><th>After day 9</th><td>3</td><td>3</td><td>3</td><td>2</td><td class="highlight">2</td></tr>
					<tr><th>After day 10</th><td class="highlight">2</td><td>3</td><td>3</td><td>2</td><td>2</td></tr>
					<tr><th>After day 11</th><td>2</td><td class="highlight">2</td><td>3</td><td>2</td><td>2</td></tr>
					<tr><th>After day 12</th><td>2</td><td>2</td><td class="highlight">2</td><td>2</td><td>2</td></tr>
					<tr><th><strong>After day 13</strong></th><td>2</td><td>2</td><td>2</td><td class="highlight">2</td><td>2</td></tr>
					<tr><th>After day 14</th><td>2</td><td>2</td><td>2</td><td>2</td><td class="highlight">1</td></tr>
					<tr><th>After day 15</th><td class="highlight">1</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
					<tr><th>After day 16</th><td>1</td><td class="highlight">1</td><td>2</td><td>2</td><td>1</td></tr>
					<tr><th>After day 17</th><td>1</td><td>1</td><td class="highlight">1</td><td>2</td><td>1</td></tr>
					<tr><th>After day 18</th><td>1</td><td>1</td><td>1</td><td class="highlight">1</td><td>1</td></tr>
					<tr><th>After day 19</th><td>1</td><td>1</td><td>1</td><td>1</td><td class="highlight"><strong>0</strong></td></tr>
				</tbody>
			</table>
		</div>
	</div>

	<h3>The mistake I made last week</h3>
	<p>At this point, I decided to try to find a way to determine the state of the system after all the values had been decremented such that the smallest value was equal to 1, then continue the daily loop from there. That is, I would start on day 3 in sample 1 and on day 14 in sample 2 (and on day several billion in the maximal case).

	<p>While struggling to find an efficient algorithm to find this day and its corresponding values, I forgot part of the problem. I started thinking that not only was ink not used on Sundays, <em>but also that the pen pointer was not incremented on Sundays</em>. In hindsight, this is exactly equivalent to simply decrementing the ink and advancing the pen pointer each day, which would be very easy indeed to implement. By coincidence, my implementation of this incorrect algorithm (which I hadn't then realized could be simplified that much) had an off-by-one error that caused it to return the correct result for the first sample case.

	<p>I spent the next hour or so trying to find the error in my implementation causing the answer for the second test case to be incorrect before realizing it was the algorithm itself that was entirely incorrect.

	<p><strong>Tip: Always try to calculate the sample inputs on paper to make sure you understand the problem correctly!</strong> You may even stumble into an efficient solution in the process.

	<h3>Another insufficiently efficient solution</h3>
	<p>After recollecting myself and going back to the correct tables above, I noticed that the pattern in the value in the table was obvious for each pen, rather than each day. Take pen 4 in sample 2, for instance. It starts with 4 ml of ink. This is then decremented on day 5<i>n</i> + 3 (n ∈ <b>Z</b>), except when <code>day % 7 == 6</code>. The following algorithm (<a href="/solutions/pens-vertical.cpp">pens-vertical.cpp</a>) naturally arises from this observation:

<pre>#include &lt;iostream&gt;
#include &lt;climits&gt;

int main() {
    int n;
    unsigned long long int minDay = ULLONG_MAX;
    int minPen = 0;
    std::cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        int ink;
        std::cin &gt;&gt; ink;

        unsigned long long int day = i;
        for(;;) {
            if(day % 7 == 6) {
                day += n;
                if(day % 7 == 6) {
                    break; // pen is never used
                }
            }
            ink--;
            if(day &gt;= minDay) {
                break; // pen is not the first to run out of ink
            }
            if(!ink) {
                minDay = day;
                minPen = i;
                break; // pen ran out of ink
            }
            day += n;
        }
    }
    std::cout &lt;&lt; minPen + 1 &lt;&lt; '\n';
    return 0;
}</pre>

	<p>Guess what? <strong>This isn't good enough either.</strong> If it is billions of days before a pen runs out of ink, there are still millions of calculations to be done on each pen. I again <a href="pens-vertical-modified.cpp">modified this program</a> to report the <a href="pens-vert.1h">state after one hour</a> and used this data to estimate that this program would complete in <strong>TIME</strong>on my system.
	<p>Really, this algorithm is only marginally better than the first algorithm; the only calculations that are skipped by this algorithm are those for days after the first pen runs out of ink&mdash;and then only if the first pen given is the first to run out of ink.

	<h3>Optimizing the above algorithm</h3>
	<p>This algorithm certainly <em>feels</em> nicer than the first one (to me, anyway)&mdash;the calculations it's doing are much more straightforward, but there are still too many of them.
	<p>How can we determine the day on which each pen runs out of ink mathematically rather than with brute force?

	<h3>Another idea</h3>
	<p>What if we combined days into blocks such that each pen's ink is decreased by the same amount in each row of the table?

	[table]

	<p>This would make it very easy to determine how many rows of the table are needed before each pen runs out of ink. But how do we know which pen runs out of ink first if two pens now run out in the same row (block of days)?

	<p>The width of this table is lcm(7, n). A full LCM implementation is not needed&mdash;not only because one is now <a href="https://en.cppreference.com/w/cpp/numeric/lcm">included in CPP</a>, but because lcm of a prime and a variable integer can be simplified to:

	[code]
</article>
